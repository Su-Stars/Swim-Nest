## 깃허브 코드 관리 전략

---

배포 브랜치는 `main` 으로 하게 됩니다.

각자 새로운 기능, 혹은 추상적인 범위를 담당하게 될 겁니다.

따라서, 이에 따른 브랜치를 각자 생성하여 수정 혹은 추가하고, 이를 `main` 에 병합하게 됩니다.

<br/>

### 브랜치 생성 규칙

만약 유저에 대한 `controller`, `service` 를 수정 및 추가한다면,

`feat/<본인의 이름 초성>/users` 로 새로운 브랜치를 생성하면 됩니다.

예를 들어 저는 "공담형" 이므로, `gdh` 가 됩니다.

저는 유저 기능에 대한 브랜치를 만들게 되면, `feat/gdh/users` 로 새로운 브랜치를

`main` 으로부터 생성 할 겁니다.

<br/>

또한, 만약에 인증 관련으로 프로그램을 수정하게 된다면, `feat/gdh/auth` 가 될 겁니다.

혹은 이미지 기능을 만들게 된다면, `feat/gdh/image` 가 될 겁니다.

(문서를 변경한다면, `docs/gdh`) 로 지을 수도 있겠습니다.

<br/>

### 브랜치 병합 규칙

`main` 브랜치에 병합하여 프로덕션 환경으로 올려놓기 위해 

각자 새로운 내용을 브랜치에 기입하게 됩니다.

`main` 브랜치는 `git push origin main` 으로 코드를 밀면 안되며,

파생된 원격 브랜치에서 `main` 브랜치로 PR 을 날려 병합하게 됩니다.

이는 코드의 병합 도중 충돌 가능성을 예방하려는 규칙입니다.

<br/>

그렇다면, 싱크로를 맞추면서 어떻게 `main` 브랜치에 push 할까? 라는 의문이 생길수도 있는데,

저는 충돌을 예방하기 위해 이러한 방식을 사용합니다 :

**(아직 수정을 시작하기 전이라 가정)**

1. 현재 원격 `main` 브랜치와, 로컬 `main` 브랜치가 존재합니다.
2. 팀원의 변경 이력(히스토리) 가 있을 가능성을 대비하여, 원격의 `main` 과 로컬의 `main` 을 병합합니다.
    * `(main) $ git pull origin main`
3. 그리고, 현재 변경을 시작하려는 자신의 로컬 브랜치 - 예 : (`feat/gdh/users`) 에 병합합니다.
    * `(main) $ git checkout feat/gdh/users` --> `(feat/gdh/users) $ git merge main`
    * 이를 통해 방금 최신화 된 로컬 `main` 과 `feat/gdh/users` 내용을 병합합니다.
4. 이제 로컬에서 `feat/gdh/users` 브랜치에서 유저에 대한 변경사항을 적용합니다.
5. 변경사항을 적용하기 위해, `feat/gdh/users` 의 커밋들을 `origin feat/gdh/users` 로 push 합니다.
6. 그리고 현재 변경사항이 원격 사이트의 `feat/gdh/users` 에 올라가 있으므로, `main` 에 PR 을 날립니다.

이러한 방식으로 각 브랜치의 변경 사항을 최신화 하고, PR 을 날립니다.

혹시 다른 방식이 있으시다면 Slack DM 으로 날려주세요.

<br/>

### 예정된 추가 사항

Node.js 와 같이, Nest 도 jest 를 통한 테스팅이 가능합니다.

변경사항을 만들고 나서, 프로덕션에 올린 뒤 기능에 대한 에러를 보고받고, 이를 다시 올리는 데는 시간이 오래 걸립니다.

따라서, 이번에는 TDD 전용 브랜치를 만들어서, 

**Trigger** 를 PR 로 만들고, 해당 TDD 파일들이 통과 할 시, `main` 으로 통과할 수 있게 만들까 생각 중입니다.

(예시 : `feat/gdh/users` --> `test` --> `main`)
